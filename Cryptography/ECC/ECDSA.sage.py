

# This file was *autogenerated* from the file ECDSA.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f = Integer(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_16 = Integer(16)
from sage.all import *
import random
import os

class ECC :
    def __init__(self,p,a,b) :
        E = EllipticCurve(GF(p),[a,b])
        N = E.order()
        G = E.gen(_sage_const_0 )

    def keygen(self,n) :
        private_key = random.randrange(_sage_const_1 ,n)
        public_key = private_key*G
        return private_key,public_key
        
    def sign_message(self,dA,message) :
        z = int(sha256(message).hexdigest(),_sage_const_16 )
        r=_sage_const_0 
        s=_sage_const_0 
        while r==_sage_const_0  or s==_sage_const_0  :
            k = random.randrange(_sage_const_1 ,N)
            x,y = (k*G).xy()
            r = int(x)
            s = ((((int(z) + int(r)*int(dA))%N)*inverse_mod(int(k),N)))%N

        return (r,s)

    def verify_signature(self,H,message,signature) :
        z = int(sha256(message).hexdigest(),_sage_const_16 )
        r,s = signature
        w = inverse_mod(int(s),N)
        u1 = (int(w)*z)%N
        u2 = (int(w)*r)%N
        x,y = (u1*G + u2*H).xy()
        if x == r :
            return 'Signature matches'
        else :
            return 'Invalid Signature'


def test() :
    p=_sage_const_0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f 
    a=_sage_const_0 
    b=_sage_const_7 
    E = ECC(p,a,b)
    message = os.urandom(_sage_const_16 )
    Alice = E.keygen(E.N)
    Bob = E.keygen(E.N)
    if E.verify_signature(Alice[_sage_const_1 ],message,sign_message(Alice[_sage_const_0 ],message)) == 'Signature matches' :
        return 'Test passed'




if __name__ == "__main__" :
    print test()

